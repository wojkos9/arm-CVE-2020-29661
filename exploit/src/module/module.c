#include <linux/pid.h>
#include <linux/types.h>
#include <linux/module.h>
#include <linux/printk.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/device.h>
#include <asm/errno.h>

#include "asm-generic/pgtable-nopud.h"
#include "asm/memory.h"
#include "asm/pgtable-2level.h"
#include "asm/ptrace.h"
#include "asm/thread_info.h"
#include "asm/uaccess.h"
#include "exm.h"
#include "linux/gfp.h"
#include "linux/mm.h"
#include "linux/mm_types.h"
#include "linux/sched.h"
#include "linux/nsproxy.h"
#include "linux/pid_namespace.h"
#include "linux/slab.h"
#include "linux/slub_def.h"
#include "linux/kprobes.h"
#include "linux/pid.h"
#include "asm/pgtable.h"

#define DEV_NAME "exm"

static struct class *cls;

struct alloc_data {
    void *cache_addr;
};

static struct pid *saved_pid = NULL;
static struct page *saved_page = NULL;

int alloc_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct alloc_data *data = (struct alloc_data *)ri->data;
    long retval = regs_return_value(regs);
    if (data->cache_addr == init_pid_ns.pid_cachep
        && retval == (long)saved_pid) {
        pr_info("[KP] pid_cache alloc %lx\n", retval);
    }
    return 0;
}

int alloc_e_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct alloc_data *data = (struct alloc_data *)ri->data;
    void *cache = (void*)regs->ARM_r0;
    data->cache_addr = cache;
    // dump_stack();
    return 0;
}

int free_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct alloc_data *data = (struct alloc_data *)ri->data;
    if (data->cache_addr) {
        pr_info("[KP] pid_cache FREE %p val %x off %x [PID] *\n", data->cache_addr, saved_pid->count.counter, init_pid_ns.pid_cachep->offset);
    }
    // dump_stack();

    return 0;
}

int free_e_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct alloc_data *data = (struct alloc_data *)ri->data;
    struct kmem_cache *cache = (void*)regs->ARM_r0;
    void *ptr = (void*)regs->ARM_r1;
    // struct page *page = virt_to_head_page(ptr);
    if (cache == init_pid_ns.pid_cachep && ptr == saved_pid) {
        data->cache_addr = ptr;
    } else {
        data->cache_addr = NULL;
    }
    // dump_stack();
    return 0;
}

int partial_handler(struct kprobe *ri, struct pt_regs *regs) {
    struct page *page = (void*)regs->ARM_r1;
    if (page == saved_page) {
        pr_info("[PART] put partial page **********\n");
    }
    return 0;
}

struct kretprobe alloc_probe = {
    .kp = {
        .symbol_name = "kmem_cache_alloc"
    },
    .data_size = sizeof(struct alloc_data),
    .entry_handler = alloc_e_handler,
    .handler = alloc_handler
};

struct kretprobe free_probe = {
    .kp = {
        .symbol_name = "kmem_cache_free"
    },
    .data_size = sizeof(struct alloc_data),
    .entry_handler = free_e_handler,
    .handler = free_handler
};

struct kprobe parial_probe = {
    .symbol_name = "put_cpu_partial",
    .pre_handler = partial_handler
};

static void setup_kprobe(void) {
    register_kretprobe(&alloc_probe);
    register_kretprobe(&free_probe);
    register_kprobe(&parial_probe);
    disable_kprobe(&parial_probe);
}

#define STR(x) #x
#define PTE_TEST(x) if (pte & x) pr_info(" " #x " %x", x)

void print_lpte(pte_t pte) {
    PTE_TEST(L_PTE_VALID);
    PTE_TEST(L_PTE_PRESENT);
    PTE_TEST(L_PTE_YOUNG);
    PTE_TEST(L_PTE_DIRTY);
    PTE_TEST(L_PTE_RDONLY);
    PTE_TEST(L_PTE_USER);
    PTE_TEST(L_PTE_XN);
    PTE_TEST(L_PTE_SHARED);
    PTE_TEST(L_PTE_NONE);
    pr_info("\n");
}

void print_hpte(pte_t pte) {
}

pte_t *pte_by_addr(ulong addr) {
    struct mm_struct *mm = current_thread_info()->task->mm;
    pgd_t *pgd = pgd_offset(mm, addr);
    pud_t *pud = pud_offset(pgd, addr);
    pmd_t *pmd = pmd_offset(pud, addr);
    pte_t *pte = pte_offset_map(pmd, addr);
    return (void*)pte + 2048;
}

static long exm_ioctl(struct file *filp, uint iocn, ulong iocp) {
    switch (iocn) {
        case IOC_PID_ADDR:
        {
            struct pid *pid;
            ulong pid_nr = iocp;
            pid = find_vpid(pid_nr);
            pr_info("[KP] pid_cache alloc %lx [PID] *\n", (long)pid);
            saved_pid = pid;
            saved_page = virt_to_head_page(pid);
            // enable_kretprobe(&alloc_probe);
            enable_kprobe(&parial_probe);
            return (ulong)pid;
        }
        case IOC_PID_REFCNT:
        {
            struct pid *pid = saved_pid;//(struct pid *)iocp;
            return pid->count.counter;
        }
        case IOC_CHK_PAGE:
        {
            pr_info("[PG] inuse %d\n", saved_page->inuse);
            return 0;
        }
        case IOC_ALLOC_PID:
        {
            saved_pid = kmem_cache_alloc(init_pid_ns.pid_cachep, GFP_KERNEL);
            saved_page = virt_to_head_page(saved_pid);
            enable_kretprobe(&alloc_probe);
            enable_kprobe(&parial_probe);
            return (ulong)saved_pid;
        }
        case IOC_FREE_PID:
        {
            kmem_cache_free(init_pid_ns.pid_cachep, saved_pid);
            return 0;
        }
        case IOC_DEC_PID:
        {
            saved_pid->count.counter--;
            return 0;
        }
        case IOC_GET_PID:
        {
            return (ulong)saved_pid;
        }
        case IOC_PTE:
        {
            ulong addr = iocp;
            pte_t *pte = pte_by_addr(addr);
            pr_info("[PTE] %p=%x %x\n", pte, *pte, *(int*)((void*)pte + 2048));
            // print_lpte(*pte);
            return 0;
        }
        case IOC_GET_PTE:
        {
            ulong addr = iocp;
            pte_t *pte = pte_by_addr(addr);
            return (ulong)*pte;
        }
        case IOC_SET_PTE:
        {
            struct pte_op op;
            pte_t *pte;
            if (copy_from_user(&op, (void __user *)iocp, sizeof(op)) != 0) {
                pr_alert("Bad IOC_SET_PTE data\n");
                return -1;
            }
            pte = pte_by_addr(op.addr);
            *pte = op.pte_val;
            return 0;
        }
    }
    return 0;
}

static struct file_operations exm_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = exm_ioctl
};

int init_module(void) {
    int ret;
    printk(KERN_INFO "Init exploit module2\n");
    ret = register_chrdev(EXM_MAJOR, DEV_NAME, &exm_fops);
    if (ret == -1) {
        printk(KERN_ERR "Error registering device");
        return ret;
    }
    cls = class_create(THIS_MODULE, DEV_NAME);
    device_create(cls, NULL, MKDEV(EXM_MAJOR, 0), NULL, DEV_NAME);
    setup_kprobe();
    disable_kretprobe(&alloc_probe);
    return 0;
}

void cleanup_module(void) {
    unregister_kretprobe(&alloc_probe);
    device_destroy(cls, MKDEV(EXM_MAJOR, 0));
    class_destroy(cls);
    unregister_chrdev(EXM_MAJOR, DEV_NAME);
}


MODULE_LICENSE("GPL");
