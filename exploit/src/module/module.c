#include <linux/pid.h>
#include <linux/types.h>
#include <linux/module.h>
#include <linux/printk.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/device.h>
#include <asm/errno.h>
#include <stdarg.h>

#include "asm-generic/pgtable-nopud.h"
#include "asm/memory.h"
#include "asm/page.h"
#include "asm/pgtable-2level.h"
#include "asm/ptrace.h"
#include "asm/stacktrace.h"
#include "asm/thread_info.h"
#include "asm/uaccess.h"
#include "exm.h"
#include "linux/gfp.h"
#include "linux/kernel.h"
#include "linux/mm.h"
#include "linux/mm_types.h"
#include "linux/percpu-defs.h"
#include "linux/rcupdate.h"
#include "linux/sched.h"
#include "linux/nsproxy.h"
#include "linux/pid_namespace.h"
#include "linux/semaphore.h"
#include "linux/slab.h"
#include "linux/slub_def.h"
#include "linux/kprobes.h"
#include "linux/pid.h"
#include "asm/pgtable.h"
#include "linux/smp.h"
#include "linux/stacktrace.h"

#define DEV_NAME "exm"

#define KCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res < 0)   \
        pr_alert("KCHK(" #x ")\n"); \
    __res;                        \
})

static struct class *cls;

struct alloc_data {
    void *cache_addr;
};

ulong msg_page = 0;
char msg_page_data[64];

static struct pid *saved_pid = NULL;
ulong pid_page = 0;
static struct page *saved_page = NULL;

const struct cred *saved_cred;

// int free_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
//     struct alloc_data *data = (struct alloc_data *)ri->data;
//     if (data->cache_addr) {
//         pr_info("[KP] pid_cache FREE %p val %x off %x [PID] *\n", data->cache_addr, saved_pid->count.counter, init_pid_ns.pid_cachep->offset);
//     }

//     return 0;
// }

// int free_e_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
//     struct alloc_data *data = (struct alloc_data *)ri->data;
//     struct kmem_cache *cache = (void*)regs->ARM_r0;
//     void *ptr = (void*)regs->ARM_r1;
//     // struct page *page = virt_to_head_page(ptr);
//     if (cache == init_pid_ns.pid_cachep && ptr == saved_pid) {
//         data->cache_addr = ptr;
//     } else {
//         data->cache_addr = NULL;
//     }
//     // dump_stack();
//     return 0;
// }

int partial_handler(struct kprobe *ri, struct pt_regs *regs) {
    struct page *page = (void*)regs->ARM_r1;
    if (page == saved_page) {
        pr_info("[PART] put partial page **********\n");
    }
    return 0;
}

struct kprobe parial_probe = {
    .symbol_name = "put_cpu_partial",
    .flags = KPROBE_FLAG_DISABLED,
    .pre_handler = partial_handler
};

int load_msg_h(struct kretprobe_instance *ri, struct pt_regs *regs) {
    long rval = regs_return_value(regs);
    long pid_page = (long)saved_pid & PAGE_MASK;
    long page = rval & PAGE_MASK;
    int  offs = (rval & ~PAGE_MASK) / 64;
    bool trace = pid_page == 0 || page == pid_page;
    if (trace) {
        struct page *ppage = virt_to_head_page((void*)page);
        if (page != msg_page) {
            int i;
            for (i = 0; i < 64; i++) {
                msg_page_data[i] = '.';
            }
            msg_page = page;
        }
        msg_page_data[offs] = 'X';
        pr_info("[MSG] ALOC %.64s inuse %d\n", msg_page_data, ppage->inuse);
        msg_page_data[offs] = '*';
    }
    return 0;
}

struct kretprobe load_msg_probe = {
    .kp = {
        .symbol_name = "load_msg",
        .flags = KPROBE_FLAG_DISABLED
    },
    .handler = load_msg_h
};

int free_msg_h(struct kprobe *ri, struct pt_regs *regs) {
    ulong msg = regs->ARM_r0;
    long page = msg & PAGE_MASK;
    int offs = (msg & ~PAGE_MASK) / 64;
    if (page == msg_page) {
        struct page *ppage = virt_to_head_page((void*)msg);
        msg_page_data[offs] = 'O';
        pr_info("[MSG] FREE %.64s inuse %d\n", msg_page_data, ppage->inuse);
        msg_page_data[offs] = '.';
    }
    return 0;
}

struct kprobe free_msg_probe = {
    .symbol_name = "free_msg",
    .flags = KPROBE_FLAG_DISABLED,
    .pre_handler = free_msg_h
};

struct bt_data {
    char *buf;
    int n;
    int skip;
};

int print_frame(struct stackframe *frame, void *data) {
    struct bt_data *btd = data;
    int dn;
    // if (btd->skip) {
    //     btd->skip--;
    //     return 0;
    // }
    dn = snprintf(btd->buf, btd->n, "%pS ", (void*)frame->pc);
    btd->buf += dn;
    btd->n -= dn;
    return 0;
}

void snbacktrace(char buf[], int n, struct pt_regs *regs) {
    struct stackframe frame;
    struct bt_data data = { buf, n, 1 };
    arm_get_current_stackframe(regs, &frame);
    walk_stackframe(&frame, print_frame, &data);
}

void backtrace(struct pt_regs *regs, const char *fmt, ...) {
    va_list ap;
    char buf[960];
    va_start(ap, fmt);
    vprintk(fmt, ap);
    snbacktrace(buf, sizeof(buf), regs);
    va_end(ap);
    printk("%s\n", buf);
}

void alloc_post_h(struct kprobe *p, struct pt_regs *regs, unsigned long f) {
    struct kmem_cache *cache = (void*)regs->ARM_r0;
    ulong obj = (ulong)raw_cpu_ptr(cache->cpu_slab)->freelist;
    ulong page = obj & PAGE_MASK;
    if (page == msg_page) {
        int offs = (obj & ~PAGE_MASK) / 64;
        msg_page_data[offs] = 'P';
        pr_info("\n[PID] ALOC %.64s\n", msg_page_data);
        msg_page_data[offs] = 'p';
        backtrace(regs, "[FRAME] ALOC %lx: ", obj);
        pr_info("\n");
    }
}

struct kprobe alloc_probe = {
    .symbol_name = "kmem_cache_alloc",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = alloc_post_h
};

void free_post_h(struct kprobe *p, struct pt_regs *regs, unsigned long f) {
    void *obj = (void*)regs->ARM_r1;
    ulong addr = (ulong)obj;
    ulong page = addr & PAGE_MASK;
    if (page == pid_page) {
        int offs = (addr & ~PAGE_MASK) / 64;
        msg_page_data[offs] = 'U';
        pr_info("[PID] kmem_cache_free %p %.64s\n", obj, msg_page_data);
        msg_page_data[offs] = '.';
        backtrace(regs, "[FRAME] kmem_cache_free pid: ");
        pr_info("\n");
    }
}

struct kprobe free_probe = {
    .symbol_name = "kmem_cache_free",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = free_post_h
};

void free_post2_h(struct kprobe *p, struct pt_regs *regs, unsigned long f) {
    void *obj = (void*)regs->ARM_r0;
    ulong addr = (ulong)obj;
    ulong page = addr & PAGE_MASK;
    if (page == pid_page) {
        int offs = (addr & ~PAGE_MASK) / 64;
        msg_page_data[offs] = 'U';
        pr_info("[PID] free %.64s %p\n", msg_page_data, obj);
        msg_page_data[offs] = '.';
        backtrace(regs, "[FRAME] kfree: ");
        pr_info("\n");
    }
}

struct kprobe free_probe2 = {
    .symbol_name = "kfree",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = free_post2_h
};

struct bt_trackdata {
    long last_pc;
    int call_cnt;
    int last_cpu;
    char last_buf[1024];
};

void track_func(const char *tag, struct pt_regs *regs, struct bt_trackdata *td) {
    long pc = regs->ARM_lr;
    if (pc == td->last_pc) {
        td->call_cnt++;
    } else {
        if (td->call_cnt > 1) {
            printk("[%s][%d] %s +%d\n", tag, td->last_cpu, td->last_buf, td->call_cnt - 1);
        }
        // snbacktrace(td->last_buf, sizeof(td->last_buf), regs);
        printk("[%s][%d] %s\n", tag, get_cpu(), td->last_buf);
        td->last_pc = pc;
        td->last_cpu = get_cpu();
        td->call_cnt = 1;
    }
}

void get_pid_h(struct kprobe *p, struct pt_regs *regs, unsigned long f) {
    static struct bt_trackdata td;
    struct pid *pid = (void*)regs->ARM_r0;
    if (pid == saved_pid) {
        track_func("GETPID", regs, &td);
    }
}

struct kprobe get_pid_p = {
    .symbol_name = "get_pid",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = get_pid_h
};

void put_pid_h(struct kprobe *p, struct pt_regs *regs, unsigned long f) {
    static struct bt_trackdata td;
    struct pid *pid = (void*)regs->ARM_r0;
    if (pid == saved_pid) {
        track_func("PUTPID", regs, &td);
    }
}

struct kprobe put_pid_p = {
    .symbol_name = "put_pid",
    .post_handler = put_pid_h
};


static void setup_kprobe(void);


#define PTE_TEST(x) if (pte & x) pr_info(" " #x " %x", x)

void print_lpte(pte_t pte) {
    PTE_TEST(L_PTE_VALID);
    PTE_TEST(L_PTE_PRESENT);
    PTE_TEST(L_PTE_YOUNG);
    PTE_TEST(L_PTE_DIRTY);
    PTE_TEST(L_PTE_RDONLY);
    PTE_TEST(L_PTE_USER);
    PTE_TEST(L_PTE_XN);
    PTE_TEST(L_PTE_SHARED);
    PTE_TEST(L_PTE_NONE);
    pr_info("\n");
}

void print_hpte(pte_t pte) {
}

pte_t *pte_by_addr(ulong addr) {
    struct mm_struct *mm = current_thread_info()->task->mm;
    pgd_t *pgd = pgd_offset(mm, addr);
    pud_t *pud = pud_offset(pgd, addr);
    pmd_t *pmd = pmd_offset(pud, addr);
    pte_t *pte = pte_offset_map(pmd, addr);
    return (void*)pte + 2048;
}


void cred_h(struct kprobe *p, struct pt_regs *regs, ulong flags) {
    struct cred *cred = (void*)regs->ARM_r0;
    if (cred == saved_cred) {
        backtrace(regs, "[CREDS] PUT_CREDS %p ->%d\n", cred, cred->usage.counter - 1);
    }
}

struct kprobe cred_probe = {
    .symbol_name = "put_cred",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = cred_h
};

void gcred_h(struct kprobe *p, struct pt_regs *regs, ulong flags) {
    struct cred *cred = (void*)regs->ARM_r0;
    if (cred == saved_cred) {
        backtrace(regs, "[CREDS] GET_CREDS %p ->%d\n", cred, cred->usage.counter + 1);
    }
}

struct kprobe gcred_probe = {
    .symbol_name = "get_cred",
    .flags = KPROBE_FLAG_DISABLED,
    .post_handler = gcred_h
};

void find_cred(void) {
    const struct cred *cred = current->cred;
    saved_cred = cred;
    pr_info("[CRED] cred = %p usage = %d security = %p\n", cred, cred->usage.counter, cred->security);
    // enable_kprobe(&gcred_probe);
    // enable_kprobe(&cred_probe);
}

static long exm_ioctl(struct file *filp, uint iocn, ulong iocp) {
    switch (iocn) {

        case IOC_PID_ADDR:
        {
            struct pid *pid;
            ulong pid_nr = iocp;
            pid = find_vpid(pid_nr);
            pr_info("[KP] ioctl PID = %08lx *\n", (long)pid);
            saved_pid = pid;
            pid_page = (long)saved_pid & PAGE_MASK;
            saved_page = virt_to_head_page(pid);
            // enable_kretprobe(&alloc_probe);
            enable_kprobe(&parial_probe);
            return (ulong)pid;
        }
        case IOC_CRED:
        {
            find_cred();
            return 0;
        }
        case IOC_PID_REFCNT:
        {
            return saved_pid->count.counter;
        }
        case IOC_CHK_PAGE:
        {
            pr_info("[PAGE] inuse %d\n", saved_page->inuse);
            return 0;
        }
        case IOC_ALLOC_PID:
        {
            saved_pid = kmem_cache_alloc(init_pid_ns.pid_cachep, GFP_KERNEL);
            pid_page = (long)saved_pid & PAGE_MASK;
            saved_page = virt_to_head_page(saved_pid);
            enable_kprobe(&parial_probe);
            return (ulong)saved_pid;
        }
        case IOC_FREE_PID:
        {
            kmem_cache_free(init_pid_ns.pid_cachep, saved_pid);
            return 0;
        }
        case IOC_DEC_PID:
        {
            pr_info("[DEC] %d -> %d\n", saved_pid->count.counter, saved_pid->count.counter-1);
            saved_pid->count.counter--;
            return 0;
        }
        case IOC_GET_PID:
        {
            return (ulong)saved_pid;
        }
        case IOC_PTE:
        {
            ulong addr = iocp;
            pte_t *pte = pte_by_addr(addr);
            pr_info("[PTE] %p=%x %x\n", pte, *pte, *(int*)((void*)pte + 2048));
            // print_lpte(*pte);
            return 0;
        }
        case IOC_GET_PTE:
        {
            ulong addr = iocp;
            pte_t *pte = pte_by_addr(addr);
            return (ulong)*pte;
        }
        case IOC_SET_PTE:
        {
            struct pte_op op;
            pte_t *pte;
            if (copy_from_user(&op, (void __user *)iocp, sizeof(op)) != 0) {
                pr_alert("Bad IOC_SET_PTE data\n");
                return -1;
            }
            pte = pte_by_addr(op.addr);
            *pte = op.pte_val;
            return 0;
        }
        case IOC_TRACE_MSG:
        {
            bool enable = iocp;
            pr_info("[MSG] ENABLE %d\n", enable);
            if (enable) {
                enable_kretprobe(&load_msg_probe);
                enable_kprobe(&free_msg_probe);
                enable_kprobe(&alloc_probe);
                enable_kprobe(&free_probe);
                enable_kprobe(&free_probe2);
            } else {
                disable_kretprobe(&load_msg_probe);
            }
            return 0;
        }
        case IOC_WAIT_RCU:
        {
            // synchronize_rcu();
            return 0;
        }

    }
    return 0;
}

static struct file_operations exm_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = exm_ioctl
};

int init_module(void) {
    int ret;
    printk(KERN_INFO "Init exploit module2\n");
    ret = register_chrdev(EXM_MAJOR, DEV_NAME, &exm_fops);
    if (ret == -1) {
        printk(KERN_ERR "Error registering device");
        return ret;
    }
    cls = class_create(THIS_MODULE, DEV_NAME);
    device_create(cls, NULL, MKDEV(EXM_MAJOR, 0), NULL, DEV_NAME);
    setup_kprobe();
    return 0;
}

void cleanup_module(void) {
    device_destroy(cls, MKDEV(EXM_MAJOR, 0));
    class_destroy(cls);
    unregister_chrdev(EXM_MAJOR, DEV_NAME);
}

static void setup_kprobe(void) {
    register_kprobe(&alloc_probe);
    KCHK(register_kprobe(&free_probe));
    KCHK(register_kprobe(&free_probe2));
    // KCHK(register_kprobe(&get_pid_p));
    // KCHK(register_kprobe(&put_pid_p));
    register_kprobe(&parial_probe);
    register_kretprobe(&load_msg_probe);
    // register_kprobe(&free_msg_probe);
    KCHK(register_kprobe(&cred_probe));
    KCHK(register_kprobe(&gcred_probe));
}

MODULE_LICENSE("GPL");
